// ******************************************************************************************
// This protocol is UNSTABLE in the sense of being subject to change.
// ******************************************************************************************

syntax = "proto3";

package kurrentdb.protocol.v2.streams;

option csharp_namespace = "KurrentDB.Protocol.V2.Streams";

import "google/protobuf/struct.proto";

service StreamsService {
  // Executes an atomic operation to append records to multiple streams.
  // This transactional method ensures that all appends either succeed
  // completely, or are entirely rolled back, thereby maintaining strict
  // data consistency across all involved streams.
  rpc Append(AppendRequest) returns (AppendResponse);

  // Streaming version of Append that allows clients to send multiple
  // append requests continuously. Once completed, all records are
  // appended transactionally (all succeed or fail together).
  // Provides improved efficiency for high-throughput scenarios while
  // maintaining the same transactional guarantees.
  rpc AppendSession(stream AppendRequest) returns (AppendSessionResponse);
}


// Represents the input for appending records to a specific stream.
message AppendRequest {
  // The name of the stream to append records to.
  string stream = 1;
  // The records to append to the stream.
  repeated AppendRecord records = 2;
  // The expected revision of the stream. If the stream's current revision does
  // not match, the append will fail.
  // The expected revision can also be one of the special values
  // from ExpectedRevisionConstants.
  // Missing value means no expectation, the same as EXPECTED_REVISION_CONSTANTS_ANY
  optional sint64 expected_revision = 3 [jstype = JS_STRING];
}

// Represents the outcome of an append operation.
message AppendResponse {
  // The name of the stream to which records were appended.
  string stream = 1;
  // The expected revision of the stream after the append operation.
  int64 stream_revision = 2 [jstype = JS_STRING];
  // The position of the last appended record in the stream.
  optional int64 position = 4 [jstype = JS_STRING];
}

message AppendSessionResponse {
  // The results of each append request in the session.
  repeated AppendResponse output = 1;
  // The position of the last appended record in the session.
  int64 position = 2 [jstype = JS_STRING];
}

// Represents the data format of the schema.
enum SchemaFormat {
  // Default value, should not be used.
  SCHEMA_FORMAT_UNSPECIFIED = 0;
  SCHEMA_FORMAT_JSON        = 1;
  SCHEMA_FORMAT_PROTOBUF    = 2;
  SCHEMA_FORMAT_AVRO        = 3;
  SCHEMA_FORMAT_BYTES       = 4;
}

message SchemaInfo {
  // The format of the schema that the record conforms to.
  SchemaFormat format  = 1;
  // The name of the schema that the record conforms to.
  string name = 2;
  // The identifier of the specific version of the schema that the record payload
  // conforms to. This should match a registered schema version in the system.
  // Not necessary when not enforcing schema validation.
  optional string id = 3;
}

// Record to be appended to a stream.
message AppendRecord {
  // Universally Unique identifier for the record. Must be a guid.
  // If not provided, the server will generate a new one.
  optional string record_id = 1;
  // The timestamp of when the record was created, represented as
  // milliseconds since the Unix epoch. This is primarily for
  // informational purposes and does not affect the ordering of records
  // within the stream, which is determined by the server.
  // If not provided, the server will assign it upon receipt.
  optional int64 timestamp = 2 [jstype = JS_STRING];
  // A collection of properties providing additional information about the
  // record. This can include user-defined metadata or system properties.
  // System properties are uniquely identified by the "$." prefix.
  map<string, google.protobuf.Value> properties = 3;
  // Information about the schema that the record payload conforms to.
  SchemaInfo schema = 4;
  // The actual data payload of the record.
  bytes data = 5;
}

// Constants that match the expected state of a stream during an
// append operation. It can be used to specify whether the stream should exist,
// not exist, or can be in any state.
enum ExpectedRevisionConstants {
  // The stream should exist and have a single event.
  EXPECTED_REVISION_CONSTANTS_SINGLE_EVENT = 0;
  // It is not important whether the stream exists or not.
  EXPECTED_REVISION_CONSTANTS_ANY = -2;
  // The stream should not exist. If it does, the append will fail.
  EXPECTED_REVISION_CONSTANTS_NO_STREAM = -1;
  // The stream should exist
  EXPECTED_REVISION_CONSTANTS_EXISTS = -4;
}
